---
title: "Blunt-nosed Leopard Lizard Data Analysis: Behavior and Thermoregulation vs Water Physiology"
author: "Savannah Weaver"
output: 
  rmdformats::html_clean:
    highlight: tango
    thumbnails: FALSE
    toc: TRUE
    toc_depth: 3
---

# Packages

```{r setup, echo=T, results='hide', message=FALSE}
`%nin%` = Negate(`%in%`)
if (!require("tidyverse")) install.packages("tidyverse") 
library("tidyverse")# for dplyr workflow of calculations
if (!require("lmerTest")) install.packages("lmerTest") 
library("lmerTest") # LMMs
if (!require("ggplot2")) install.packages("ggplot2")
library("ggplot2") # plots
if (!require("RColorBrewer")) install.packages("RColorBrewer")
library("RColorBrewer") # pretty colors
if (!require("ggpubr")) install.packages("ggpubr")
library("ggpubr") # for multi-ggplot figs
if (!require("Hmisc")) install.packages("Hmisc")
library("Hmisc") # correlation matrix
if (!require("emmeans")) install.packages("emmeans")
library("emmeans") # marginal means & confints
if (!require("car")) install.packages("car")
library("car") # Anova
if (!require("rmdformats")) install.packages("rmdformats")
library("rmdformats") # clean html R markdown format
```

# Set Colors & Themes

```{r}
savs_ggplot_theme <- theme_classic() + 
                     theme(text = element_text(color = "black", 
                                               family = "sans", 
                                               size = 12),
                           axis.text = element_text(color = "black", 
                                                    family = "sans", 
                                                    size = 8),
                           legend.text = element_text(color = "black", 
                                                      family = "sans", 
                                                      size = 8),
                           legend.text.align = 0,
                           legend.position = "bottom"
                           )

savs_ggplot_theme2 <- theme_classic() + 
                     theme(text = element_text(color = "black", 
                                               family = "sans", 
                                               size = 10),
                           axis.text = element_text(color = "black", 
                                                    family = "sans", 
                                                    size = 10),
                           legend.text = element_text(color = "black", 
                                                      family = "sans", 
                                                      size = 8),
                           legend.text.align = 0,
                           legend.position = "bottom"
                           )

my_brew_cols_4 <- brewer.pal(11, "RdYlBu")[c(5,4,10,11)] # this one!
```






# Background

This data was collected on Blunt-nosed Leopard Lizards (*Gambelia sila*) during their active season in 2021. In this document, we will compute metrics of thermoregulation and behavior, then assess whether differences in those variables could be related to differences in hydric physiology.

All of the data wrangling and preparation for the thermal and microhabitat use data is done within this document, but is done in the 'wrangling\_' documents for the hydric data.

First, we compute maximum temperatures and thermoregulatory accuracy (thermal metrics) and microhabitat use for each lizard at different time intervals, then we pair that with our hydric physiology data, and look for any relationships.





# Load & Wrangle Data

## Lizard Data

This is the same dataframe used in 'analysis_1'. For info on data preparation, see the 'wrangling\_' files, and for an explanation of each of the variable names, see that section in 'analysis_1'.

```{r}
# measurement dates
apr_may_dates <-  as.Date(c("2021-04-23", "2021-04-24", "2021-04-25"))
may_dates <- as.Date(c("2021-05-07", "2021-05-08", "2021-05-09"))
  
liz_dat <- read_rds("./data/G_sila_clean_full_dat.RDS") %>%
  # we only use data for radio collared lizards in this analysis
  dplyr::filter(complete.cases(radio_collar_serial)) %>%
  # add date chunks to help look at values over time
  mutate(date_chunks = factor(case_when(capture_date %in% apr_may_dates ~ "Apr 26 - May 6",
                                 capture_date %in% may_dates ~ "May 10 - 20")),
         radio_collar_serial = factor(radio_collar_serial))
summary(liz_dat)

# subsets by date
liz_dat_apr_may_only <- liz_dat %>%
  dplyr::filter(complete.cases(date_chunks))
liz_dat_july_only <- liz_dat %>%
  dplyr::filter(month == "July")

# ID info only
liz_IDs_only <- liz_dat %>%
  group_by(radio_collar_serial, individual_ID, sex_M_F) %>%
  summarise(n = n()) %>%
  dplyr::select(-n)
```

## Validation

This is a dataframe I can use to make sure we do not have data for these lizards after these dates, because they were either found dead or their dropped collars were found.

```{r}
check_gone <- data.frame(Serial = factor(c("229-072", # found dead June 7
                                           "229-060", # collar found May 18
                                           "229-074", # collar found April 28
                                           "229-070", # became -a on May 8
                                           "245-762", # became -a on May 8
                                           "229-073", # dropped sometime before May msmts
                                           "245-751"  # died May 7/8
                                           )),
                         date_def_gone = as.Date(c("2021-06-07", "2021-05-18",
                                                   "2021-04-28", "2021-05-07",
                                                   "2021-05-07", "2021-05-07",
                                                   "2021-05-07"),
                                                 format = "%Y-%m-%d"))
check_gone
```

## Tsurf Wrangling

We measured the surface body temperature of lizards throughout the study using Holohil temperature-sensitive transmitters, which is the data we load in this section.

variables in this dataframe:

-   DateTime = date and time the temperature was logged
-   Serial = the radio-collar serial number for that observation (to be used to link to specific individuals)
-   Freq = what radio frequency the collar was on
-   pp = the pulse period recorded by the radio-collar receiver (pulse period is a proxy for temperature)
-   ppTempC = the pp value converted into temperature in degrees Celsius using third order polynomial functions estimated from the reference transformations provided by Holohil

```{r}
temps <- read.csv("./data/telemetry/tower_temps_all.csv") %>%
  # properly format data classes
  mutate(date_only = as.Date(substr(DateTime, 1, 10), format = "%Y-%m-%d"),
         hour_of_day = as.numeric(substr(DateTime, 12, 13)),
         DateTime = as.POSIXct(DateTime, format = "%Y-%m-%d %H:%M:%S"),
         Serial = (paste(substr(Serial, 1, 3), 
                               substr(Serial, 4, 7), sep = "-")),
         Freq = round(Freq, 2))

# look at temps dataframe
summary(temps)
unique(temps$Serial)
```

Check whether we have observations on lizards that were not alive or were not actually wearing their radio-collars because they dropped them.

```{r}
temp_check <- temps %>%
  left_join(check_gone, by = 'Serial') %>%
  dplyr::filter(date_only > date_def_gone) %>%
  arrange(Serial) %>%
  dplyr::select(Serial, date_only, date_def_gone)
unique(temp_check$Serial)
```

Great... we have data for all 7 individuals that we need to clean up for

```{r}
temps2 <- temps %>%
  # delete the obs for all Serials but 229-070 & 245-762
  dplyr::filter(!(Serial == "229-072" & date_only >= "2021-06-07")) %>%
  dplyr::filter(!(Serial == "229-060" & date_only >= "2021-05-18")) %>%
  dplyr::filter(!(Serial == "229-074" & date_only >= "2021-04-28")) %>%
  dplyr::filter(!(Serial == "229-073" & date_only >= "2021-05-07")) %>%
  dplyr::filter(!(Serial == "245-751" & date_only >= "2021-05-07")) %>%
  # change the serial and ID of F-08 and M-03 to be "-a" bc collar was switched
          # for F-08a
  mutate(Serial = replace(Serial, # what I want to change
                          Serial == "229-070" & # if this
                          date_only > "2021-05-07", # and this
                          "229-070a"), # change to this
         # for M-03a
         Serial = replace(Serial, # what I want to change
                          Serial == "245-762" & # if this
                          date_only > "2021-05-07", # and this
                          "245-762a"), # change to this
         Serial = factor(Serial))
```

Check that it worked:

```{r}
temps_doublecheck <- temps %>%
  # SAVE the obs for all Serials but 229-070 & 245-762
  dplyr::filter((Serial == "229-072" & date_only >= "2021-06-07") |
                  (Serial == "229-060" & date_only >= "2021-05-18") |
                  (Serial == "229-074" & date_only >= "2021-04-28") |
                  (Serial == "229-073" & date_only >= "2021-05-07") |
                  (Serial == "245-751" & date_only >= "2021-05-07"))
nrow(temps_doublecheck) + nrow(temps2) == nrow(temps)

temp_check2 <- temps2 %>%
  left_join(check_gone, by = 'Serial') %>%
  dplyr::filter(date_only > date_def_gone) %>%
  arrange(Serial) %>%
  dplyr::select(Serial, date_only, date_def_gone)
temp_check2
unique(temps2$Serial)
```

Subset the temperature data so that we do not use the temperatures from during hydric measurement periods. Also add columns for time interval chunks to make averaging easier later.

```{r}
# capture weekend dates
cap_dates <- as.Date(c("2021-04-23", "2021-04-24", "2021-04-25", # April
                        "2021-05-07", "2021-05-08", "2021-05-09"), # May
                     format = "%Y-%m-%d")

# grouping notes by date
group_dates <- data.frame(date_only = c(seq(as.Date("2021-04-26"), 
                                            as.Date("2021-07-13"), by = 1))) %>%
  dplyr::filter(date_only %nin% cap_dates) %>%
  mutate(date_chunks = factor(c(rep("Apr 26 - May 6", 11), 
                                rep("May 10 - 20", 11), 
                                rep("May 21 - 31", 11),
                                rep("Jun 1 - 11", 11),
                                rep("Jun 12 - 22", 11),
                                rep("Jun 23 - Jul 3", 11), 
                                rep("Jul 4 - 13", 10)),
                              levels = c("Apr 26 - May 6", "May 10 - 20", 
                                         "May 21 - 31", "Jun 1 - 11", "Jun 12 - 22", 
                                         "Jun 23 - Jul 3", "Jul 4 - 13")))

# subset dataset and add grouping notes
temp_sub <- temps2 %>%
  dplyr::filter(date_only %nin% cap_dates) %>%
  left_join(group_dates, by = 'date_only')
summary(temp_sub)
```

I also need to remove outliers, which are pretty standard erroneous points when using temperature-sensitive telemetry with devices external to the animal. I will follow Nicole Gaudenti's 2021 paper, and exclude "any outliers greater than two standard deviations away from each lizard's mean Tb"

Look at data distribution:

```{r}
boxplot(temp_sub$ppTempC)
hist(temp_sub$ppTempC)
ggplot(temp_sub) +
  geom_point(aes(x = Serial,
                 y = ppTempC,
                 color = Serial)) +
  theme_classic()
ggplot(temp_sub) +
  geom_boxplot(aes(x = Serial,
                 y = ppTempC,
                 color = Serial)) +
  theme_classic()
```

Get mean and SD for each lizard's Tb data, then use it to filter out extreme values:

```{r}
temp_clean <- temp_sub %>%
  group_by(Serial) %>%
  #summarise(outs = boxplot.stats(ppTempC)$out) # less outliers found this way
  mutate(mean_Tb = mean(ppTempC),
         sd_Tb = sd(ppTempC)) %>%
  mutate(accept_low = mean_Tb - (2*sd_Tb),
         accept_high = mean_Tb + (2*sd_Tb)) %>%
  dplyr::filter(ppTempC < accept_high & ppTempC > accept_low) %>%
  dplyr::select(-mean_Tb, -sd_Tb, -accept_low, -accept_high)

summary(temp_clean)
```

What proportion of points did we remove?

```{r}
(nrow(temp_sub) - nrow(temp_clean))/nrow(temp_sub)
```

4.5%

Plot again:

```{r}
ggplot(temp_clean) +
  geom_point(aes(x = Serial,
                 y = ppTempC,
                 color = Serial)) +
  theme_classic()
ggplot(temp_clean) +
  geom_boxplot(aes(x = Serial,
                 y = ppTempC,
                 color = Serial)) +
  theme_classic()
```

Individual IQRs definitely look reasonable.

Also, save the link between radio frequency and transmitter serial number to help with microhabitat data wrangling.

```{r}
freq_serial <- temp_clean %>%
  group_by(Freq, Serial) %>%
  summarise(n = n()) #%>%
# check that there is 1 serial per frequency
#  group_by(Freq) %>%
 # summarise(n = n())

```

## Microhabitat Use

This data was collected by radio-tracking lizards, finding them, then recording what type of microhabitat they were in. We have to read-in a few files, because at first the formatting was not consistent, then put the dataframes all together.

variables in this dataframe:

-   Serial = the radio-collar serial number for that observation (to be used to link to specific individuals)
-   DateTime = date and time the temperature was logged
-   microhabitat (was Micro_1) = which microhabitat lizards were observed in
-   Breed_Col = breeding coloration of lizards (we will not use)
-   bpmTempC = the temperature in Celsius from the lizards' collar, based on the handheld receivers used to locate them, which record the pulse interval in beats per minute rather than the pulse period of the tower receiver for other Tb data
-   dwsTempOut = the temperature recorded by a weather station at the study site; these values were interpolated to the specific time of the observation since the weather station was only recording data every two hours ModTempC = the ground surface temperature estimated by a temperature model (Ian Axsom) for the location and time that each observation occurred; this is an estimate of the operative temperature available to these lizards

This is the nice, clean data that was collected early May onwards:

```{r}
microhab_clean <- read.csv("./data/telemetry/behavior_observations.csv") %>%
  # force NAs on, then remove, observations for the "uncollared" lizard
  mutate(Serial_no = as.numeric(substr(Serial, 1, 5))) %>%
  dplyr::filter(complete.cases(Serial_no)) %>%
  # properly format data classes
  mutate(date_only = as.Date(substr(DateTime, 1, 10), format = "%Y-%m-%d"),
          hour_of_day = as.numeric(substr(DateTime, 12, 13)),
          DateTime = as.POSIXct(DateTime, format = "%Y-%m-%d %H:%M:%S"),
          Serial = factor(paste(paste(substr(as.character(Serial), 1, 3), 
                                     substr(as.character(Serial), 4, 7), sep = "-"))),
         microhabitat = factor(Micro_1,
                               labels = c("Burrow", # keep
                                          "Open", # change from Burrow slide
                                          "Open", # change from Burrow-Partial
                                          "Burrow", # change from Burrow/ephedra
                                          "Burrow", # change from Burrow/shrub
                                          "", ### change from Dead/Missing ###
                                          "Open", # change from Grass trims
                                          "", # change from IDK
                                          "", # change from No Visual
                                          "Open", # keep
                                          "Shade - Full", # keep
                                          "Shade - Partial", # keep
                                          "Shade - Partial", # remove notes
                                          "Shade - Partial", # remove notes
                                          "Shade - Partial", # remove notes
                                          "Shade - Partial", # remove notes
                                          "Shade - Partial", # remove notes
                                          "Shade - Partial", # remove notes
                                          "Shade - Partial" # remove notes
                                          ))
         ) %>%
  # for some reason, it only works to fix the order separately
  mutate(microhabitat = factor(microhabitat,
                               levels = c("Open", 
                                          "Shade - Partial", 
                                          "Shade - Full", 
                                          "Burrow"
                                          #"No Visual", "Dead/Missing"
                                          ))) %>%
  dplyr::select(Serial, DateTime, date_only, hour_of_day, microhabitat, 
                bpmTempC, dwsTempOut, ModTempC) %>%
  # add date interval chunk grouping notes
  dplyr::filter(date_only %nin% cap_dates)
```

This is the messy data collected in late April and very early May. Unfortunately, the following radio-frequencies were unable to be linked to a radio collar serial number: 150.14, 150.19, 150.21, and 150.28. But, that only applied to 11 observations.

```{r}
microhab_early0 <- read.csv("./data/telemetry/behavior_observations_early_0.csv") %>%
  dplyr::select(date_only = date, time, 
                microhabitat = micro, 
                Serial = serial, 
                Freq = freq, freq_notes = X)
# this one must be split by whether freq or serial number of radio collars recorded
microhab_early0_freq_only <- microhab_early0 %>%
  dplyr::filter(!complete.cases(Serial)) %>%
  dplyr::select(-Serial)
microhab_early0_serial <- microhab_early0 %>%
  dplyr::filter(complete.cases(Serial)) %>%
  mutate(Serial = factor(paste(substr(Serial, 1, 3), 
                               substr(Serial, 4, 7), sep = "-")))

# load other csv, and add the dfs above to it
microhab_early_all <- read.csv("./data/telemetry/behavior_observations_early_1.csv") %>%
  dplyr::select(date_only = date, time, 
                microhabitat = micro, 
                Freq = freq, freq_notes) %>%
  rbind(microhab_early0_freq_only) %>%
  mutate(Freq = round(Freq, 2)) %>%
  left_join(freq_serial, by = 'Freq') %>%
  dplyr::select(-n) %>%
  rbind(microhab_early0_serial) %>%
  mutate(DateTime = as.POSIXct(paste(date_only, time, sep = " "), 
                               format = "%m/%d/%y %H:%M"),
         hour_of_day = as.numeric(substr(as.character(DateTime), 12, 13)),
         date_only = as.Date(date_only, format = "%m/%d/%y"),
         microhabitat = factor(str_to_title(microhabitat))) %>%
  dplyr::filter(complete.cases(Serial, microhabitat)) %>%
  # some of these were "focal observations" taken every few minutes
  # to be consistent with other obs, take first point of each focal
  group_by(Serial, date_only) %>%
  #summarise(min(date), max(date), min(time), max(time)) # check that data is one chunk
  # might remove a few usable data, but OK
  slice(1) %>%
  # remove these to make it easy to bind to clean one
  dplyr::select(-time, -Freq, -freq_notes) %>%
  # add these to make it easy to bind to clean one
  mutate(bpmTempC = NA, dwsTempOut = NA, ModTempC = NA)
summary(microhab_early_all) 
```

Now, put together the original and messy-now-clean dataframes, and add some formatting:

```{r}
microhab_pre <- microhab_clean %>%
  rbind(microhab_early_all) %>%
  dplyr::filter(complete.cases(microhabitat)) %>%
  left_join(group_dates, by = 'date_only') %>%
  left_join(liz_IDs_only, by = c('Serial' = 'radio_collar_serial')) %>%
  mutate(above_below = factor(case_when(microhabitat == "Burrow" ~ "Belowground",
                                        microhabitat != "Burrow" ~ "Aboveground"),
                              levels = c("Aboveground", "Belowground")))

summary(microhab_pre)
```

Check whether we have observations on lizards that were not alive or were not actually wearing their radio-collars because they dropped them.

```{r}
microhab_check <- microhab_pre %>%
  left_join(check_gone, by = 'Serial') %>%
  dplyr::filter(date_only > date_def_gone) %>%
  arrange(Serial) %>%
  dplyr::select(individual_ID, Serial, date_only, date_def_gone)
microhab_check
```

Check what the name switch should be for F-08 and M-03:

```{r}
unique(liz_dat$radio_collar_serial)
unique(liz_dat$individual_ID)
```

Then fix those things:

```{r}
microhab <- microhab_pre %>%
  # delete the one obs for F-17 that was outside the valid date range
  dplyr::filter(!(individual_ID == "F-17" & date_only == "2021-05-19")) %>%
  # change the serial and ID of F-08 to be "-a" bc collar was switched
          # for F-08a
  mutate(individual_ID = replace(individual_ID, # what I want to change
                                 individual_ID == "F-08" & # if this
                                   date_only > "2021-05-07", # and this
                                 "F-08a"), # change to this
         Serial = replace(Serial, # what I want to change
                          Serial == "229-070" & # if this
                          date_only > "2021-05-07", # and this
                          "229-070a"), # change to this
         # for M-03a
         individual_ID = replace(individual_ID, # what I want to change
                                 individual_ID == "M-03" & # if this
                                   date_only > "2021-05-07", # and this
                                 "M-03a"), # change to this
         Serial = replace(Serial, # what I want to change
                          Serial == "245-762" & # if this
                          date_only > "2021-05-07", # and this
                          "245-762a") # change to this
         )
```

Check that worked:

```{r}
nrow(microhab) == nrow(microhab_pre) -1

microhab_check2 <- microhab %>%
  left_join(check_gone, by = 'Serial') %>%
  dplyr::filter(date_only > date_def_gone) %>%
  arrange(Serial) %>%
  dplyr::select(individual_ID, Serial, date_only, date_def_gone)
microhab_check2
```


### Export full microhab df

```{r}
#write_rds(microhab, "./data/telemetry_clean_2021.RDS")
```



*methods stats*: How many observations and days was each lizard tracked for?

```{r}
micro_obs_ns <- microhab %>%
  group_by(Serial) %>%
  summarise(n = n(),
            min_date = min(date_only),
            max_date = max(date_only),
            date_range = max_date - min_date) %>%
  mutate(per_day = n/as.numeric(date_range),
         per_wk = per_day*7)
micro_obs_ns %>%
  dplyr::filter(Serial != "252-882") %>%
  summarise(mean(n), sd(n),
            mean(date_range), sd(date_range),
            mean(per_wk), sd(per_wk))
```

# Thermal Metrics

For each lizard, we want to calculate some assessment of how hot they let themselves be, and their thermoregulatory accuracy.

## Daily Maximums

```{r}
daily_max <- temp_clean %>%
  # quick look to use
  #dplyr::filter(date_chunks %in% c("Apr 26 - May 6", "May 10 - 20")) %>%
  
  # first do daily maximums
  group_by(date_only, date_chunks, Serial) %>%
  mutate(Tb_percentile_50 = quantile(ppTempC, 0.5),
         Tb_percentile_60 = quantile(ppTempC, 0.6),
         Tb_percentile_70 = quantile(ppTempC, 0.7),
         Tb_percentile_80 = quantile(ppTempC, 0.8),
         Tb_percentile_90 = quantile(ppTempC, 0.9)) %>%
  ungroup() %>%
  # select only the data between the 80-90th percentiles of Tb for each lizard
  dplyr::filter(ppTempC > Tb_percentile_80 & ppTempC < Tb_percentile_90) %>%
  # calculate the mean Tb for that subset for each lizard per day
  group_by(date_only, date_chunks, Serial) %>%
  summarise(daily_Tb_percentile_80_90 = mean(ppTempC)) %>%
  # then do the mean Tb between 80-90%ile for each lizard per time chunk (~11 days)
  group_by(date_chunks, Serial) %>%
  summarise(chunk_avg_Tb_percentile_80_90 = mean(daily_Tb_percentile_80_90))
summary(daily_max)
```

## Db

From Kat Ivey's 2020 paper, Tset range is: 32.3±1.2 - 37.5±1.1 deg C.

From Nicole Gaudenti's 2021 paper, Tset range: 33.2-37.9 deg C.

I will use the widest margin created by both: 32.3 (Ivey) - 37.9 (Gaudenti)

```{r}
Db <- temp_clean %>%
  # we only want daytime Tb for this
  # currently using Kat's limits
  dplyr::filter(hour_of_day <=19 & hour_of_day >=7) %>%
  mutate(Tpref_low = 32.3,
         Tpref_high = 37.9) %>%
  # calculate Db for every Tb measurement
  mutate(Db = case_when(#ppTempC < Tpref_low ~ ppTempC - Tpref_low, # for pos/neg version
                        ppTempC < Tpref_low ~ Tpref_low - ppTempC, # for abs value version
                        ppTempC > Tpref_high ~ ppTempC - Tpref_high,
                        ppTempC < Tpref_high & ppTempC > Tpref_low ~ 0)) %>%
  # then avg Db by lizard & date chunk
  group_by(date_chunks, Serial) %>%
  summarise(chunk_mean_Db_deg_C_diff = mean(Db))

summary(Db)
```

# Microhabitat Use

## Proportions of Observations

To calculate microhabitat use, I literally just calculate the proportion of observations for a given individual/time range that were in each microhabitat.

So, for each time chunk, for each lizard (radio-collar serial), I need to get the following values:

-   number of total observations
-   number of observations in each microhabitat
-   proportion of observations in each microhabitat
-   aboveground temps based on Ian's model ?

**We do not have a lot of obs for each lizard for every time chunk, so how many observations should there be to make the proportions valid/reasonable?** One potential way to do this could be to at least have 1-2 obs for every microhabitat type we are trying to observe (so, minimum points per date chunk either 4 or 8, once I get rid of the irrelevant ones).

```{r}
# where to cut off n obs?
microhab %>%
  # get only 1 per lizard
  group_by(date_chunks, Serial) %>%
  summarise(n_obs = n()) %>%
  ungroup() %>%
  # How many lizards have each (n) obs?
  group_by(n_obs) %>%
  summarise(n = n())
```

It seems like a good cut-off is a minimum of 4 observations per lizard, per time chunk. Otherwise, we would lose a LOT of data.

```{r}
# micro use BY individual lizard
MH_use_by_indiv <- microhab %>%
  group_by(Serial, date_chunks, microhabitat) %>%
  summarise(n_obs_micro = n()) %>%
  group_by(Serial, date_chunks) %>%
  mutate(n_obs_total = sum(n_obs_micro)) %>%
  ungroup() %>%
  # expect that this takes out 42 obs/rows
  dplyr::filter(n_obs_total >= 4) %>%
  mutate(MH_use_proportion = n_obs_micro/n_obs_total) #%>%
# check that all proportions for a given lizard and time chunk = 1
#  group_by(Serial, date_chunks) %>%
 # summarise(prop_total = sum(MH_use_proportion))
head(MH_use_by_indiv)
summary(MH_use_by_indiv)

# micro use for all lizards in the study, aggregated
MH_use_across_indivs <- microhab %>%
  group_by(date_chunks, microhabitat) %>%
  summarise(n_obs_micro = n(),
            mean_mod_temp = mean(ModTempC, na.rm = T)) %>%
  group_by(date_chunks) %>%
  mutate(n_obs_total = sum(n_obs_micro),
         mean_mod_temp2 = mean(mean_mod_temp, na.rm = T)) %>%
  ungroup() %>%
  mutate(MH_use_proportion = n_obs_micro/n_obs_total)
head(MH_use_across_indivs)

# micro use for all lizards, BY SEX
MH_use_across_indivs_sex <- microhab %>%
  group_by(date_chunks, microhabitat, sex_M_F) %>%
  summarise(n_obs_micro = n(),
            mean_mod_temp = mean(ModTempC, na.rm = T)) %>%
  group_by(date_chunks, sex_M_F) %>%
  mutate(n_obs_total = sum(n_obs_micro),
         mean_mod_temp2 = mean(mean_mod_temp, na.rm = T)) %>%
  ungroup() %>%
  mutate(MH_use_proportion = n_obs_micro/n_obs_total)
summary(MH_use_across_indivs_sex)
```








## Proportion of time aboveground

A version of microhabitat use that's basically burrow/not.

```{r}
prop_above_by_indiv <- MH_use_by_indiv %>%
  dplyr::filter(microhabitat == "Burrow") %>%
  mutate(prop_above = 1 - MH_use_proportion)
prop_above_across_indiv <- MH_use_across_indivs %>%
  dplyr::filter(microhabitat == "Burrow") %>%
  mutate(prop_above = 1 - MH_use_proportion)
prop_above_across_indiv_by_sex <- MH_use_across_indivs_sex %>%
  dplyr::filter(microhabitat == "Burrow") %>%
  mutate(prop_above = 1 - MH_use_proportion)
```



## Onset of Estivation

This didn't make it into the paper, because the estivation onset dates we got were somewhat questionable, and we have no way of knowing whether it is due to our tracking methods and the dropping/loss of collars throughout the season.


```{r}
# first, get some key dates for each lizard
last_date <- microhab %>%
  # for each lizard
  group_by(Serial) %>%
  # what was the latest date we tracked them?
  summarise(date_last_obs = max(date_only),
            # and how many observations did they have total?
            n_obs_total = n())

last_date_above <- microhab %>%
  # first, subset aboveground obs only
  dplyr::filter(microhabitat != "Burrow") %>%
  # for each lizard
  group_by(Serial) %>%
  # what was the latest date we observed each lizard ABOVEground?
  summarise(est_onset = max(date_only))
  
estivating <- microhab %>%
  left_join(last_date_above, by = 'Serial') %>%
  dplyr::filter(date_only > est_onset) %>%
  group_by(Serial, est_onset) %>%
  # how many times did we observe each lizard while they were estivating?
  summarise(n_obs_est = n()) %>%
  left_join(last_date, by = 'Serial') %>%
  mutate(est_obs_days = as.numeric(date_last_obs - est_onset),
         prop_obs_est = n_obs_est/n_obs_total) %>%
  # make sure we tracked them after "last" aboveground observation
  dplyr::filter(est_onset < date_last_obs) %>%
  # and we still had a signal on them till the end
  dplyr::filter(date_last_obs == "2021-07-13")
summary(estivating)

estivating %>%
  mutate(est = "Yes") %>%
  group_by(est) %>%
  summarise(mean(n_obs_est),
            sd(n_obs_est),
            min(n_obs_est),
            max(n_obs_est))
```







# Max Temps ~ Hydric

Now, look for relationships between hydric physiology and thermoregulation.

## Prep Data

```{r}
max_temps_hydric <- liz_dat_apr_may_only %>%
  left_join(daily_max, by = c('date_chunks', 
                              'radio_collar_serial' = 'Serial')) %>%
  # remove NAs
  dplyr::filter(complete.cases(chunk_avg_Tb_percentile_80_90)) %>%
  # remove the one outlier wayyyyy below the other values
  dplyr::filter(chunk_avg_Tb_percentile_80_90>30)

summary(max_temps_hydric)
```

## Plots

```{r}
sub_maxs <- max_temps_hydric %>%
  dplyr::select(chunk_avg_Tb_percentile_80_90, CEWL_g_m2h, osmolality_mmol_kg_mean, mass_g, SMI)
PerformanceAnalytics::chart.Correlation(sub_maxs)

ggplot(max_temps_hydric) +
  geom_point(aes(x = CEWL_g_m2h,
                 y = chunk_avg_Tb_percentile_80_90,
                 color = date_chunks)) +
  geom_smooth(aes(x = CEWL_g_m2h,
                 y = chunk_avg_Tb_percentile_80_90),
              se = F,
              method = "lm",
              formula = y~x)
ggplot(max_temps_hydric) +
  geom_point(aes(x = osmolality_mmol_kg_mean,
                 y = chunk_avg_Tb_percentile_80_90,
                 color = date_chunks)) +
  geom_smooth(aes(x = osmolality_mmol_kg_mean,
                 y = chunk_avg_Tb_percentile_80_90),
              se = F,
              method = "lm",
              formula = y~x)
```

## Models

```{r}
# CEWL
max_temp_CEWL_mod <- lmerTest::lmer(data = max_temps_hydric,
                                chunk_avg_Tb_percentile_80_90 ~ CEWL_g_m2h +
                                  (1|individual_ID))
summary(max_temp_CEWL_mod)
#anova(max_temp_CEWL_mod, type = "3", ddf = "Kenward-Roger")
plot(max_temp_CEWL_mod)

# osmolality
max_temp_osml_mod <- lmerTest::lmer(data = max_temps_hydric,
                                chunk_avg_Tb_percentile_80_90 ~ osmolality_mmol_kg_mean +
                                  (1|individual_ID))
summary(max_temp_osml_mod)
#anova(max_temp_osml_mod, type = "3", ddf = "Kenward-Roger")
plot(max_temp_osml_mod)

# mass
max_temp_mass_mod <- lmerTest::lmer(data = max_temps_hydric,
                                chunk_avg_Tb_percentile_80_90 ~ mass_g +
                                  (1|individual_ID))
summary(max_temp_mass_mod)
#anova(max_temp_mass_mod, type = "3", ddf = "Kenward-Roger")
plot(max_temp_mass_mod)

# SMI
max_temp_SMI_mod <- lmerTest::lmer(data = max_temps_hydric,
                                chunk_avg_Tb_percentile_80_90 ~ SMI +
                                  (1|individual_ID))
summary(max_temp_SMI_mod)
#anova(max_temp_SMI_mod, type = "3", ddf = "Kenward-Roger")
plot(max_temp_SMI_mod)


# supplemental hydration tmt
max_temp_tmt_mod <- lmerTest::lmer(data = max_temps_hydric,
                                chunk_avg_Tb_percentile_80_90 ~ tmt +
                                  (1|individual_ID))
summary(max_temp_tmt_mod)
#anova(max_temp_tmt_mod, type = "3", ddf = "Kenward-Roger")
plot(max_temp_tmt_mod)
```

# Db ~ Hydric

## Prep Data

```{r}
db_hydric <- liz_dat_apr_may_only %>%
  left_join(Db, by = c('date_chunks', 
                              'radio_collar_serial' = 'Serial')) %>%
  # remove NAs
  dplyr::filter(complete.cases(chunk_mean_Db_deg_C_diff)) %>%
  # remove outliers
  dplyr::filter(chunk_mean_Db_deg_C_diff > -4)

summary(db_hydric)
```

## Plots

```{r}
sub_db <- db_hydric %>%
  dplyr::select(chunk_mean_Db_deg_C_diff, CEWL_g_m2h, osmolality_mmol_kg_mean, mass_g, SMI)
PerformanceAnalytics::chart.Correlation(sub_db)

ggplot(db_hydric) +
  geom_point(aes(x = CEWL_g_m2h,
                 y = chunk_mean_Db_deg_C_diff,
                 color = date_chunks)) +
  geom_smooth(aes(x = CEWL_g_m2h,
                 y = chunk_mean_Db_deg_C_diff),
              se = F,
              method = "lm",
              formula = y~x)
ggplot(db_hydric) +
  geom_point(aes(x = osmolality_mmol_kg_mean,
                 y = chunk_mean_Db_deg_C_diff,
                 color = date_chunks)) +
  geom_smooth(aes(x = osmolality_mmol_kg_mean,
                 y = chunk_mean_Db_deg_C_diff),
              se = F,
              method = "lm",
              formula = y~x)
```

## Models

```{r}
# CEWL
db_CEWL_mod <- lmerTest::lmer(data = db_hydric,
                                chunk_mean_Db_deg_C_diff ~ CEWL_g_m2h +
                                  (1|individual_ID))
summary(db_CEWL_mod)
plot(db_CEWL_mod)

# osmolality
db_osml_mod <- lmerTest::lmer(data = db_hydric,
                                chunk_mean_Db_deg_C_diff ~ osmolality_mmol_kg_mean +
                                  (1|individual_ID))
summary(db_osml_mod)
plot(db_osml_mod)

# mass
db_mass_mod <- lmerTest::lmer(data = db_hydric,
                                chunk_mean_Db_deg_C_diff ~ mass_g +
                                  (1|individual_ID))
summary(db_mass_mod)
plot(db_mass_mod)

# SMI
db_SMI_mod <- lmerTest::lmer(data = db_hydric,
                                chunk_mean_Db_deg_C_diff ~ SMI +
                                  (1|individual_ID))
summary(db_SMI_mod)
plot(db_SMI_mod)

# supplemental water tmt
db_tmt_mod <- lmerTest::lmer(data = db_hydric,
                                chunk_mean_Db_deg_C_diff ~ tmt +
                                  (1|individual_ID))
summary(db_tmt_mod)
```

# Microhabitat ~ Hydric

## Prep Data

I actually need to prep the microhabitat data- the metric I will investigate is proportion of time aboveground.

```{r}
prop_above_hydric <- prop_above_by_indiv %>%
  dplyr::filter(date_chunks %in% c("Apr 26 - May 6", "May 10 - 20"))
```

```{r}
micro_hydric <- liz_dat_apr_may_only %>%
  left_join(prop_above_hydric, by = c('date_chunks', 
                              'radio_collar_serial' = 'Serial')) %>%
  # remove NAs
  dplyr::filter(complete.cases(prop_above)) 

summary(micro_hydric)
```

## Plots

```{r}
sub_micro <- micro_hydric %>%
  dplyr::select(prop_above, CEWL_g_m2h, osmolality_mmol_kg_mean, mass_g, SMI)
PerformanceAnalytics::chart.Correlation(sub_micro)


ggplot(MH_use_by_indiv) + 
    geom_bar(aes(x = date_chunks,
                 y = MH_use_proportion,
                 fill = microhabitat
                 ),
             position = "fill", 
             stat = "identity") +
  facet_wrap(~Serial) +
  theme_classic()

ggplot(micro_hydric) +
  geom_point(aes(x = CEWL_g_m2h,
                 y = prop_above,
                 color = date_chunks)) +
  geom_smooth(aes(x = CEWL_g_m2h,
                 y = prop_above),
              se = F,
              method = "lm",
              formula = y~x)
ggplot(micro_hydric) +
  geom_point(aes(x = osmolality_mmol_kg_mean,
                 y = prop_above,
                 color = date_chunks)) +
  geom_smooth(aes(x = osmolality_mmol_kg_mean,
                 y = prop_above),
              se = F,
              method = "lm",
              formula = y~x)
```

## Models

```{r}
# CEWL
micro_CEWL_mod <- lmerTest::lmer(data = micro_hydric,
                                prop_above ~ CEWL_g_m2h +
                                  (1|individual_ID))
summary(micro_CEWL_mod)
plot(micro_CEWL_mod)

# osmolality
micro_osml_mod <- lmerTest::lmer(data = micro_hydric,
                                prop_above ~ osmolality_mmol_kg_mean +
                                  (1|individual_ID))
summary(micro_osml_mod)
plot(micro_osml_mod)

# mass
micro_mass_mod <- lmerTest::lmer(data = micro_hydric,
                                prop_above ~ mass_g +
                                  (1|individual_ID))
summary(micro_mass_mod)
plot(micro_mass_mod)

# SMI
micro_SMI_mod <- lmerTest::lmer(data = micro_hydric,
                                prop_above ~ SMI +
                                  (1|individual_ID))
summary(micro_SMI_mod)
plot(micro_SMI_mod)

# supplemental hydration tmt
micro_tmt_mod <- lmerTest::lmer(data = micro_hydric,
                                prop_above ~ tmt +
                                  (1|individual_ID))
summary(micro_tmt_mod)
```

# All Anovas

Just so they're all in one place, get all the anovas from the models above to run:

## CEWL

```{r}
anova(max_temp_CEWL_mod, type = "3", ddf = "Kenward-Roger")
anova(db_CEWL_mod, type = "3", ddf = "Kenward-Roger")
anova(micro_CEWL_mod, type = "3", ddf = "Kenward-Roger")
```

## Osmolality

```{r}
anova(max_temp_osml_mod, type = "3", ddf = "Kenward-Roger")
#summary(max_temp_osml_mod)
anova(db_osml_mod, type = "3", ddf = "Kenward-Roger")
#summary(db_osml_mod)
anova(micro_osml_mod, type = "3", ddf = "Kenward-Roger")
```

## Body Mass

```{r}
anova(max_temp_mass_mod, type = "3", ddf = "Kenward-Roger")
anova(db_mass_mod, type = "3", ddf = "Kenward-Roger")
anova(micro_mass_mod, type = "3", ddf = "Kenward-Roger")
```

## Body Condition

```{r}
anova(max_temp_SMI_mod, type = "3", ddf = "Kenward-Roger")
#summary(max_temp_SMI_mod)
anova(db_SMI_mod, type = "3", ddf = "Kenward-Roger")
anova(micro_SMI_mod, type = "3", ddf = "Kenward-Roger")
```






# Correlation "Matrix"

For each model, get the marginal Rsq for the amount of variance that's explained by fixed effects only. Then, we will use that to calculate R, and make a figure. I put "matrix" in quotations because it will be a subset of what would be presented for a full correlation matrix. 

```{r}
corrs <- data.frame(hydric_var = c(rep("CEWL", 3), rep("Plasma Osmolality", 3), 
                                   #rep("Body Mass", 3), 
                                   rep("Body Condition", 3)),
                    thermal_var = c(rep(c("Max Temp", "Db", "Micro Use"), 3)),
                    R = c(
                      # CEWL
                      cor(max_temps_hydric$CEWL_g_m2h,
                          max_temps_hydric$chunk_avg_Tb_percentile_80_90),
                      cor(db_hydric$CEWL_g_m2h, db_hydric$chunk_mean_Db_deg_C_diff),
                      cor(micro_hydric$CEWL_g_m2h, micro_hydric$prop_above),
                      # osmolality
                      cor(max_temps_hydric$osmolality_mmol_kg_mean,
                          max_temps_hydric$chunk_avg_Tb_percentile_80_90,
                          use = "complete.obs"),
                      cor(db_hydric$osmolality_mmol_kg_mean,
                          db_hydric$chunk_mean_Db_deg_C_diff,
                          use = "complete.obs"),
                      cor(micro_hydric$osmolality_mmol_kg_mean, micro_hydric$prop_above,
                          use = "complete.obs"),
                      # mass
                      # cor(max_temps_hydric$mass_g,
                      #     max_temps_hydric$chunk_avg_Tb_percentile_80_90),
                      # cor(db_hydric$mass_g, db_hydric$chunk_mean_Db_deg_C_diff),
                      # cor(micro_hydric$mass_g, micro_hydric$prop_above),
                      # body condition
                      cor(max_temps_hydric$SMI,
                          max_temps_hydric$chunk_avg_Tb_percentile_80_90),
                      cor(db_hydric$SMI, db_hydric$chunk_mean_Db_deg_C_diff),
                      cor(micro_hydric$SMI, micro_hydric$prop_above))) %>%
  mutate(hydric_var = factor(hydric_var, levels = c("CEWL", "Plasma Osmolality",
                                                    #"Body Mass", 
                                                    "Body Condition")))
                   
corrs
```




Plot it:

*removed body mass because body condition was more relevant*

```{r}
ggplot(corrs) +
  aes(x = hydric_var,
      y = thermal_var,
      fill = R) +
  geom_tile() +
  scale_fill_distiller(palette = "RdYlBu", limits = c(-1, 1),
                       name = "Correlation\nCoefficient") +
  savs_ggplot_theme2 +
  scale_y_discrete(name = NULL, labels = c("Thermoregulatory\n            Accuracy",
                                           bquote("Maximum T"[b]),
                                           "Microhabitat Use"
                                           )) +
  scale_x_discrete(name = NULL, labels = c("CEWL", "Plasma\nOsmolality",
                                           #"Body\nMass", 
                                           "Body\nCondition")) +
  # CEWL
  annotate("text", x = 1, y = 1, label = "-0.03", 
           size = 2, family = "sans", color = "black") +
  annotate("text", x = 1, y = 2, label = "-0.02", 
           size = 2, family = "sans", color = "black") +
  annotate("text", x = 1, y = 3, label = "-0.01", 
           size = 2, family = "sans", color = "black") +
  # plasma osmolality
  annotate("text", x = 2, y = 1, label = "0.007*", 
           size = 3, family = "sans", color = "black") +
  annotate("text", x = 2, y = 2, label = "0.01", 
           size = 2, family = "sans", color = "black") +
  annotate("text", x = 2, y = 3, label = "-0.001", 
           size = 2, family = "sans", color = "black") +
  # body mass
  # annotate("text", x = 3, y = 1, label = "0.04", 
  #          size = 2, family = "sans", color = "black") +
  # annotate("text", x = 3, y = 2, label = "0.03", 
  #          size = 2, family = "sans", color = "black") +
  # annotate("text", x = 3, y = 3, label = "0.004", 
  #          size = 2, family = "sans", color = "black") +
  # body condition
  annotate("text", x = 3, y = 1, label = "0.02", 
           size = 2, family = "sans", color = "black") +
  annotate("text", x = 3, y = 2, label = "0.08*", 
           size = 3, family = "sans", color = "black") +
  annotate("text", x = 3, y = 3, label = "0.005", 
           size = 2, family = "sans", color = "black") -> corr_plot

# arrange to get legend centered
ggarrange(corr_plot,
          ncol = 1, nrow = 1,
          common.legend = TRUE,
          legend = "bottom"
          ) -> corr_plot_arrange

# export
ggsave(filename = "thermal_hydric_corr_plot.pdf",
       plot = corr_plot_arrange,
       path = "./results_figures",
       device = "pdf",
       dpi = 600,
       units = "mm",
       width = 100, height = 80)
```








# Hydric Conclusion

There are basically **no detectable relationships** between water balance (CEWL, osml, or mass) and thermoregulation or microhabitat use in BNLL.

































# Microhabitat Use ONLY

## Prep Data

For logistic regression, I need to have the full, raw dataset (vs proportions by group for plots), so I will actually use the 'microhab' dataframe, created in the "Load Data" \> "Microhabitat Use" section.

## Basic Plots

```{r}
ggplot(MH_use_across_indivs_sex) + 
    geom_bar(aes(x = date_chunks,
                 y = MH_use_proportion,
                 fill = microhabitat
                 ),
             position = "fill", 
             stat = "identity") +
  theme_classic() +
  facet_wrap(~sex_M_F)
ggplot(MH_use_across_indivs) + 
    geom_bar(aes(x = date_chunks,
                 y = MH_use_proportion,
                 fill = microhabitat
                 ),
             position = "fill", 
             stat = "identity") +
  theme_classic()
```




## Logistic Regression

Start with only \~ time period/chunk:

```{r}
micro_glmm <- lme4::glmer(data = microhab, 
                           above_below ~ date_chunks +
                            (1|individual_ID),
                           family="binomial")
summary(micro_glmm)
pairs(emmeans(micro_glmm, "date_chunks"))
```

pairwise comparison groups for when I make figures:

-   Apr 26 - May 6 = A
-   May 10 - 20 = A
-   May 21 - 31 = A
-   Jun 1 - 11 = A
-   Jun 12 - 22 = B
-   Jun 23 - Jul 3 = B
-   Jul 4 - 13 = C (wow!!)

Compare a model with only \~ chunks vs chunks\*sex:

```{r}
micro_glmm_sex <- lme4::glmer(data = microhab, 
                           above_below ~ date_chunks*sex_M_F +
                            (1|individual_ID),
                           family="binomial")
summary(micro_glmm_sex)
car::Anova(micro_glmm_sex, type = 2, 
           test.statistic = "Chisq", error.estimate = "pearson")

anova(micro_glmm, micro_glmm_sex)
```

Okay, adding sex was technically a better model based on some metrics, but how many time periods was microhabitat use actually different between the sexes?

```{r}
emmeans_micro_sex_glmm_sex_diffs <- data.frame(emmeans(micro_glmm_sex, 
                          pairwise ~ sex_M_F | date_chunks)$contrasts) %>%
  dplyr::select(date_chunks, contrast, p.value)
emmeans_micro_sex_glmm_sex_diffs
```

May - June, microhabitat use was significantly different based on sex. Females were spending more time in burrows than males (based on the plots above).

To keep it simple, let's keep the main figure to showing *both* males and females aggregated over time, but I can also make a secondary figure showing their differences in microhabitat use specifically in May-early June.



## Probabilities from GLMM

Now, I want to use the model estimates/coefficients to calculate the predicted probability of lizards being belowground. First, save the estimates and standard errors. I can do this by getting the model-estimated means. Then, I can use this equation to calculate the model-predicted probability of being belowground:

p = exp(emmean) / (1 + exp(emmean))

```{r}
# one set for M-F differences
emmeans_probabilities_MF <- data.frame(emmeans(micro_glmm_sex, 
                          pairwise ~ sex_M_F | date_chunks)$emmeans) %>% 
  # calculate prob
  mutate(exp_emmean = exp(emmean),
         prob = exp_emmean / (1 + exp_emmean),
         # and confidence intervals, in case helpful
         exp_LCL = exp(asymp.LCL),
         prob_LCL = exp_LCL / (1 + exp_LCL),
         exp_UCL = exp(asymp.UCL),
         prob_UCL = exp_UCL / (1 + exp_UCL)
         ) %>% 
  # only save the probabilities for when M & F were sig diff
  dplyr::filter(date_chunks %in% c("May 10 - 20", "May 21 - 31", "Jun 1 - 11"))
emmeans_probabilities_MF

# one set for overall probabilities
emmeans_probabilities <- data.frame(emmeans(micro_glmm, "date_chunks")) %>% 
  # calculate prob
  mutate(exp_emmean = exp(emmean),
         prob = exp_emmean / (1 + exp_emmean),
         # and confidence intervals, in case helpful
         exp_LCL = exp(asymp.LCL),
         prob_LCL = exp_LCL / (1 + exp_LCL),
         exp_UCL = exp(asymp.UCL),
         prob_UCL = exp_UCL / (1 + exp_UCL)
         ) %>% 
  # only save the probabilities for when M & F were the same
  dplyr::filter(date_chunks %nin% c("May 10 - 20", "May 21 - 31", "Jun 1 - 11")
                ) %>% 
  # add "sex" col
  mutate(sex_M_F = "Both")
emmeans_probabilities

# put them together
barplot_probs <- emmeans_probabilities %>% 
  rbind(emmeans_probabilities_MF) %>% 
  dplyr::select(date_chunks, sex_M_F,
                prob, prob_LCL, prob_UCL) %>% 
  mutate(sex_M_F = factor(sex_M_F))

summary(barplot_probs)
```


















## Pretty Barplot

```{r}
ggplot() + 
  
  # raw observed proportions
  geom_bar(data = MH_use_across_indivs,
    aes(x = date_chunks,
        y = MH_use_proportion,
        fill = microhabitat
                 ),
             position = "fill", 
             stat = "identity"
    ) +
  
  # model-predicted probabilities
  geom_errorbar(data = barplot_probs,
             aes(
               x = date_chunks,
               ymin = prob_LCL,
               ymax = prob_UCL,
             ),
             color = "black",
             width = 0.1
             ) +
  
  geom_point(data = barplot_probs,
             aes(
               x = date_chunks,
               y = prob,
               shape = sex_M_F,
             ),
             color = "black",
             size = 2
             ) +
  
  # labels
  xlab("Time Period") +
  ylab("Microhabitat Use (proportion of time)") +
  
  # hydric phys msmsts
  geom_vline(xintercept = 0.5, # first weekend of msmts
             size = 0.5, # default size is 0.5
             linetype = "dashed") +
  geom_vline(xintercept = 1.5, # second weekend of msmts
             size = 0.5, 
             linetype = "dashed") +
  geom_vline(xintercept = 7.5, # last few msmts
             size = 0.5, 
             linetype = "dashed") +
  
  # pretties 
  scale_shape_manual(values = c(17, 16, 15), name = "Lizard Sex") +
  scale_fill_manual(values = my_brew_cols_4, name = "Microhabitat",
                    labels = c("Open", "Partial Shade", "Full Shade", "Burrow")) +
  scale_x_discrete(labels = c("Apr 26\n-May 6",
                              "May\n10-20",
                              "May\n21-31",
                              "Jun\n1-11",
                              "Jun\n12-22",
                              "Jun 23\n-Jul 3",
                              "Jul\n4-13"
                              ),
                   name = NULL) +
  scale_y_continuous(limits = c(0, 1.1), expand = c(0,0),
                     breaks = c(seq(0, 1, by = 0.2)),
                     labels = c(seq(0, 1, by = 0.2))) +
  
  # significance annotation for time
  annotate(geom = "text", x = 1, y = 1.08, label = "a", size = 3) +
  annotate(geom = "text", x = 2, y = 1.08, label = "a", size = 3) +
  annotate(geom = "text", x = 3, y = 1.08, label = "a", size = 3) +
  annotate(geom = "text", x = 4, y = 1.08, label = "a", size = 3) +
  annotate(geom = "text", x = 5, y = 1.08, label = "b", size = 3) +
  annotate(geom = "text", x = 6, y = 1.08, label = "b", size = 3) +
  annotate(geom = "text", x = 7, y = 1.08, label = "c", size = 3) +
  # significance annotation for sex
  annotate(geom = "text", x = 2, y = 1.015, label = "*", size = 5) +
  annotate(geom = "text", x = 3, y = 1.015, label = "*", size = 5) +
  annotate(geom = "text", x = 4, y = 1.015, label = "*", size = 5) +
  savs_ggplot_theme -> fancy_micro_plot
fancy_micro_plot

# arrange to get legend centered
ggarrange(fancy_micro_plot,
          ncol = 1, nrow = 1,
          common.legend = TRUE,
          legend = "right"
          ) -> fancy_micro_plot_arrange

ggsave(filename = "microhabitat_use.pdf",
       plot = fancy_micro_plot_arrange,
       path = "./results_figures",
       device = "pdf",
       dpi = 600,
       units = "mm",
       width = 160, height = 80)
```

